#pragma once
#include "config.h"
#include <Robot/baseBatchRobot.h>
#include <Robot/batchRobotConfig.h>
#include <Robot/robot.h>
#include <Robot/streamRobot.h>
#include <Robot/sweptVolume.cuh>
#include <Utils/cuda/cudaAlgorithms.cuh>
#include <memory>
// #include <string_view>

namespace RTCD {

    template <batchRobotConfig CFG>
    struct curveParam {
        size_t nPoPerTraj;
        size_t nTraj;
        size_t nCur;
        size_t nTPts;
        size_t nCPts;
        size_t nSegs;
        size_t nCPtsPerCur;
        size_t nCPtsPerTraj;
        size_t nSegsPerCur;
        size_t nSegsPerTraj;
        size_t robotTotalSphereCount;

        uint nCPtsPerSeg;

        std::vector<int> curveSegmentIdxToPoseIdx;
        std::vector<float> curveRadius;
        std::vector<int> curveIndices;

        CUDABuffer curveRadiusBuffer;
        CUDABuffer indexBuffer;
        CUdeviceptr curveRadiusBufferPtr;

        curveParam(std::shared_ptr<robot<CFG.DOF>> robotPtr) {
            robotTotalSphereCount                    = robotPtr->getRobotTotalSphereCount();
            std::vector<float>& sphereRadiusTemplate = robotPtr->getSphereRadii();

            nPoPerTraj = CFG.nTrajPts;
            nTraj      = CFG.BATCHSIZE;
            nCur       = CFG.BATCHSIZE * robotTotalSphereCount;
            nTPts      = CFG.BATCHSIZE * robotTotalSphereCount * CFG.nTrajPts;
            if constexpr (CFG.TYPE == LinkType::LINEAR_CURVE) {
                nCPtsPerCur = CFG.nTrajPts;
                nSegsPerCur = nCPtsPerCur - 1;
            } else if constexpr (CFG.endPointType == curveEndPointType::Normal) {
                nCPtsPerCur = CFG.nCtrlPts;
                nSegsPerCur = nCPtsPerCur - static_cast<int>(CFG.TYPE);
            } else if constexpr (CFG.endPointType == curveEndPointType::Phantom) {
                nCPtsPerCur = CFG.nCtrlPts + (static_cast<int>(CFG.TYPE) > 1) * 2;
                nSegsPerCur = nCPtsPerCur - static_cast<int>(CFG.TYPE);
            } else {
                nCPtsPerCur = CFG.nCtrlPts;
                nSegsPerCur = nCPtsPerCur - static_cast<int>(CFG.TYPE);
            }

            nCPtsPerTraj = nCPtsPerCur * robotTotalSphereCount;
            nCPts        = CFG.BATCHSIZE * nCPtsPerTraj;
            nSegsPerTraj = nSegsPerCur * robotTotalSphereCount;
            nSegs        = CFG.BATCHSIZE * nSegsPerTraj;

            if constexpr (CFG.TYPE == LinkType::CUBIC_CURVE) {
                nCPtsPerSeg = 4;
            } else if constexpr (CFG.TYPE == LinkType::QUADRATIC_CURVE) {
                nCPtsPerSeg = 3;
            } else {
                nCPtsPerSeg = 2;
            }

            // Construct mapping from curve segement index to pose index & fill the radius vector
            // Note that each curve generated by one sphere has NUM_CONTROL_POINTS + static_cast<int>(CFG.TYPE)
            // segements
            curveSegmentIdxToPoseIdx.resize(nSegs);
            curveRadius.resize(nCPts);
            curveIndices.resize(nSegs);

            for (int i = 0; i < CFG.BATCHSIZE * robotTotalSphereCount; ++i) {
                std::iota(curveIndices.begin() + i * nSegsPerCur, curveIndices.begin() + (i + 1) * nSegsPerCur,
                    i * nCPtsPerCur);
            }

            for (int i = 0; i < CFG.BATCHSIZE; ++i) {
                std::fill(curveSegmentIdxToPoseIdx.begin() + i * nSegsPerTraj,
                    curveSegmentIdxToPoseIdx.begin() + (i + 1) * nSegsPerTraj, i);
            }

            std::vector<float> branchRadius(robotTotalSphereCount * nCPtsPerCur);
            for (int i = 0; i < robotTotalSphereCount; ++i) {
                std::fill(branchRadius.begin() + i * nCPtsPerCur, branchRadius.begin() + (i + 1) * nCPtsPerCur,
                    sphereRadiusTemplate[i]);
            }
            for (int i = 0; i < CFG.BATCHSIZE; ++i) {
                std::copy(branchRadius.begin(), branchRadius.end(),
                    curveRadius.begin() + i * robotTotalSphereCount * nCPtsPerCur);
            }

            curveRadiusBuffer.alloc_and_upload(curveRadius);
            curveRadiusBufferPtr = curveRadiusBuffer.d_pointer();
            indexBuffer.alloc_and_upload(curveIndices);
        }
    };

    template <batchRobotConfig CFG>
    struct streamCurveRobot final : public streamGASRobot<CFG> {
        streamCurveRobot(std::shared_ptr<robot<CFG.DOF>> robotPtr, cudaStream_t stream, OptixDeviceContext context,
            curveParam<CFG>& curveCFG);

        void fkine(const CUdeviceptr poses);
        void fkine(const CUdeviceptr poses, const size_t nPoses);
        void updateAS(const CUdeviceptr poses) override;
        void updateAS(const CUdeviceptr poses, const size_t nTraj) override;
        void updateOBB(const size_t nTraj);
        bool updateWithMask(const CUdeviceptr mask, const size_t nTraj);
        void preAllocCurveBuffer();
        void setTemplate(const CUdeviceptr index, const CUdeviceptr radii, const CUdeviceptr segs);
        // Debugging purpose
        void downloadOBBs(std::vector<OBB>& obbs);

        curveParam<CFG>& curveCFG;
        CUdeviceptr cPointsPtr;
        CUDABuffer cPointsBuffer;
        CUDABuffer tPointsBuffer;

        // OBB and mask prefix sum
        CUDABuffer dWhereInDst;
        CUDABuffer obbBuffer;
        CUdeviceptr indexMapTemplate;
        CUDABuffer indexMap;
        CUdeviceptr cPtsCmpPtr;
        CUDABuffer cPtsCmp; // compacted control points
        CUdeviceptr radiiTemplate;
        CUdeviceptr radiiCmpPtr;
        CUDABuffer radiiCmp; // compacted radii for each control points
        CUdeviceptr segsTemplate;
    };

    template <batchRobotConfig CFG>
    class batchOptixCurveRobot final : public baseBatchRobot<CFG.NSTREAM, CFG.TYPE> {
    public:
        batchOptixCurveRobot();
        batchOptixCurveRobot(std::shared_ptr<robot<CFG.DOF>> robotPtr, std::array<cudaStream_t, CFG.NSTREAM> streams,
            OptixDeviceContext context);

        void fkine(const CUdeviceptr poses, const size_t idx) override;
        void fkine(const CUdeviceptr poses, const size_t idx, const size_t nPoses) override;
        void update(const CUdeviceptr poses, const size_t idx) override;
        void update(const CUdeviceptr poses, const size_t idx, const size_t nTraj) override;
        bool updateWithMask(const CUdeviceptr mask, const size_t idx) override;
        bool updateWithMask(const CUdeviceptr mask, const size_t idx, const size_t nPoses) override;

        void buildTraversables() override;
        constexpr unsigned int getBuildFlags() const override;
        constexpr size_t getSBTSize() const override;
        constexpr size_t getBatchSize() const override;
        constexpr size_t getTrajSize() const override { return CFG.nTrajPts; }
        constexpr size_t getDOF() const override { return CFG.DOF; }

        CUdeviceptr getOBBs(const size_t idx) const override;
        size_t getNOBBs() const override;
        size_t getNOBBs(size_t nPoses) const override;
        void updateOBBs(const size_t idx) override;
        void updateOBBs(const size_t idx, const size_t nPoses) override;
        CUdeviceptr getMapIndex(const size_t idx) const override;
        const OptixTraversableHandle getHandle(const size_t idx) const override { return robots[idx]->GASHandle; }

        void resetGraph() override;

        // Debugging purpose
        void downloadOBBs(const size_t idx, std::vector<OBB>& obbs);

    private:
        void loadCurveWeight();

    private:
        curveParam<CFG> curveCFG;
        std::shared_ptr<robot<CFG.DOF>> robotPtr;
        std::array<std::unique_ptr<streamCurveRobot<CFG>>, CFG.NSTREAM> robots;
    };

    template <batchRobotConfig CFG>
    void loadWeight(std::string fileName); // Helper function of loadCurveWeight
} // namespace RTCD

namespace RTCD { // Implementation of the streamCurveRobot
    template <batchRobotConfig CFG>
    streamCurveRobot<CFG>::streamCurveRobot(std::shared_ptr<robot<CFG.DOF>> robotPtr, cudaStream_t stream,
        OptixDeviceContext context, curveParam<CFG>& curveCFG)
        : streamGASRobot<CFG>(robotPtr, stream, context), curveCFG(curveCFG) {

        using Base = streamGASRobot<CFG>;

        // Error Detect
        int maxIdx = *std::max_element(curveCFG.curveIndices.begin(), curveCFG.curveIndices.end());
        assert(maxIdx <= curveCFG.nCPts - 1 - static_cast<int>(CFG.TYPE)
               && "Number of control points per batch is too small!");

        Base::transformBuffer.resize((CFG.DOF + 1) * curveCFG.nPoPerTraj * curveCFG.nTraj * sizeof(float4) * 3);
        Base::buildInput.type = OPTIX_BUILD_INPUT_TYPE_CURVES;

        if constexpr (CFG.TYPE == LinkType::CUBIC_CURVE) {
            Base::buildInput.curveArray.curveType = OPTIX_PRIMITIVE_TYPE_ROUND_CUBIC_BSPLINE;
            tPointsBuffer.resize(curveCFG.nTPts * sizeof(float3));
            cPointsBuffer.resize(curveCFG.nCPts * sizeof(float3));
        } else if constexpr (CFG.TYPE == LinkType::QUADRATIC_CURVE) {
            Base::buildInput.curveArray.curveType = OPTIX_PRIMITIVE_TYPE_ROUND_QUADRATIC_BSPLINE;
            tPointsBuffer.resize(curveCFG.nTPts * sizeof(float3));
            cPointsBuffer.resize(curveCFG.nCPts * sizeof(float3));
        } else if constexpr (CFG.TYPE == LinkType::LINEAR_CURVE) {
            Base::buildInput.curveArray.curveType = OPTIX_PRIMITIVE_TYPE_ROUND_LINEAR;
            // No longer needs to allocate traj points buffer because we store the traj points in cPointsBuffer
            cPointsBuffer.resize(curveCFG.nCPts * sizeof(float3));
        }

        cPointsPtr                                       = cPointsBuffer.d_pointer();
        Base::buildInput.curveArray.vertexBuffers        = &cPointsPtr;
        Base::buildInput.curveArray.numVertices          = curveCFG.nCPts;
        Base::buildInput.curveArray.vertexStrideInBytes  = sizeof(float3);
        Base::buildInput.curveArray.widthBuffers         = &curveCFG.curveRadiusBufferPtr;
        Base::buildInput.curveArray.widthStrideInBytes   = sizeof(float);
        Base::buildInput.curveArray.normalBuffers        = 0;
        Base::buildInput.curveArray.normalStrideInBytes  = 0;
        Base::buildInput.curveArray.indexBuffer          = curveCFG.indexBuffer.d_pointer();
        Base::buildInput.curveArray.indexStrideInBytes   = sizeof(int);
        Base::buildInput.curveArray.numPrimitives        = curveCFG.nSegs;
        Base::buildInput.curveArray.flag                 = OPTIX_GEOMETRY_FLAG_NONE;
        Base::buildInput.curveArray.primitiveIndexOffset = 0;
        Base::buildInput.curveArray.endcapFlags          = 1;

        unsigned int buildFlags = 0;
        if constexpr (CFG.BUILD == BuildType::COMPACT) {
            buildFlags |= (OPTIX_BUILD_FLAG_ALLOW_COMPACTION | OPTIX_BUILD_FLAG_PREFER_FAST_TRACE);
        }
        if constexpr (CFG.BUILD == BuildType::FAST_BUILD) {
            buildFlags |= OPTIX_BUILD_FLAG_PREFER_FAST_BUILD;
        }
        if constexpr (CFG.BUILD == BuildType::FAST_TRACE) {
            buildFlags |= OPTIX_BUILD_FLAG_PREFER_FAST_TRACE;
        }
        Base::accelOptions.buildFlags = buildFlags;
        Base::accelOptions.operation  = OPTIX_BUILD_OPERATION_BUILD;

        preAllocCurveBuffer();

        if constexpr (CFG.useOBB) { // overwrite build input
            std::cout << "Using OBB" << std::endl;
            Base::buildInput.curveArray.vertexBuffers = &cPtsCmpPtr;
            Base::buildInput.curveArray.widthBuffers  = &radiiCmpPtr;
            Base::buildInput.curveArray.indexBuffer   = indexMap.d_pointer();
        }
    };

    template <batchRobotConfig CFG>
    void streamCurveRobot<CFG>::preAllocCurveBuffer() {

        using Base = streamGASRobot<CFG>;

        OptixAccelBufferSizes gasBufferSizes;
        OPTIX_CHECK(optixAccelComputeMemoryUsage(Base::context, &(Base::accelOptions), &(Base::buildInput),
            1, // Number of build inputs
            &gasBufferSizes));

        Base::GASBuffer.alloc(gasBufferSizes.outputSizeInBytes);
        Base::tempBuffer.alloc(gasBufferSizes.tempSizeInBytes);

        // Allocate OBB and buffer for prefix sum and so
        if constexpr (CFG.useOBB) {

            dWhereInDst.alloc(roundUpLog2(curveCFG.nSegs) * sizeof(uint));
            obbBuffer.alloc(curveCFG.nSegs * sizeof(OBB));
            indexMap.alloc(curveCFG.nSegs * sizeof(uint));
            cPtsCmp.alloc(curveCFG.nSegs * curveCFG.nCPtsPerSeg * sizeof(float3));
            radiiCmp.alloc(curveCFG.nSegs * curveCFG.nCPtsPerSeg * sizeof(float));
            cPtsCmpPtr  = cPtsCmp.d_pointer();
            radiiCmpPtr = radiiCmp.d_pointer();

            Base::tempBuffer.expandIfNotEnough(curveCFG.nSegs * sizeof(uint));
        }


        // std::cout << "Curve GAS Memory Usage: " << gasBufferSizes.outputSizeInBytes << " bytes and "
        //           << gasBufferSizes.tempSizeInBytes << " bytes as temp buffer." << std::endl;
    }

    template <batchRobotConfig CFG>
    void streamCurveRobot<CFG>::fkine(const CUdeviceptr poses) {
        using Base = streamGASRobot<CFG>;
        batchFkineTraj(
            poses, Base::transformBuffer.d_pointer(), CFG.DOF, curveCFG.nPoPerTraj, curveCFG.nTraj, Base::stream);
        if constexpr (CFG.useOBB) {
            if constexpr (CFG.TYPE == LinkType::LINEAR_CURVE) {
                batchSphrCntrTraj(reinterpret_cast<float*>(Base::transformBuffer.d_pointer()),
                    reinterpret_cast<float*>(Base::robotPtr->getSphereCenters()),
                    reinterpret_cast<float*>(cPointsBuffer.d_pointer()), curveCFG.nPoPerTraj, CFG.BATCHSIZE,
                    reinterpret_cast<int*>(Base::robotPtr->getSphereIdxMap()), curveCFG.robotTotalSphereCount, CFG.DOF,
                    Base::stream);
            } else {
                batchSphrCntrTraj(reinterpret_cast<float*>(Base::transformBuffer.d_pointer()),
                    reinterpret_cast<float*>(Base::robotPtr->getSphereCenters()),
                    reinterpret_cast<float*>(tPointsBuffer.d_pointer()), curveCFG.nPoPerTraj, CFG.BATCHSIZE,
                    reinterpret_cast<int*>(Base::robotPtr->getSphereIdxMap()), curveCFG.robotTotalSphereCount, CFG.DOF,
                    Base::stream);

                batchGenControlPoints(reinterpret_cast<float*>(tPointsBuffer.d_pointer()),
                    reinterpret_cast<float*>(cPointsBuffer.d_pointer()), curveCFG.robotTotalSphereCount * CFG.BATCHSIZE,
                    Base::stream, CFG.nCtrlPts, CFG.nTrajPts);
            }
            updateOBB(CFG.BATCHSIZE);
        }
    }

    template <batchRobotConfig CFG>
    void streamCurveRobot<CFG>::fkine(const CUdeviceptr poses, const size_t nPoses) {
        using Base = streamGASRobot<CFG>;
        batchFkineTraj(poses, Base::transformBuffer.d_pointer(), CFG.DOF, curveCFG.nPoPerTraj, nPoses, Base::stream);
        if constexpr (CFG.useOBB) {
            if constexpr (CFG.TYPE == LinkType::LINEAR_CURVE) {
                batchSphrCntrTraj(reinterpret_cast<float*>(Base::transformBuffer.d_pointer()),
                    reinterpret_cast<float*>(Base::robotPtr->getSphereCenters()),
                    reinterpret_cast<float*>(cPointsBuffer.d_pointer()), curveCFG.nPoPerTraj, nPoses,
                    reinterpret_cast<int*>(Base::robotPtr->getSphereIdxMap()), curveCFG.robotTotalSphereCount, CFG.DOF,
                    Base::stream);
            } else {
                batchSphrCntrTraj(reinterpret_cast<float*>(Base::transformBuffer.d_pointer()),
                    reinterpret_cast<float*>(Base::robotPtr->getSphereCenters()),
                    reinterpret_cast<float*>(tPointsBuffer.d_pointer()), curveCFG.nPoPerTraj, nPoses,
                    reinterpret_cast<int*>(Base::robotPtr->getSphereIdxMap()), curveCFG.robotTotalSphereCount, CFG.DOF,
                    Base::stream);

                batchGenControlPoints(reinterpret_cast<float*>(tPointsBuffer.d_pointer()),
                    reinterpret_cast<float*>(cPointsBuffer.d_pointer()), curveCFG.robotTotalSphereCount * nPoses,
                    Base::stream, CFG.nCtrlPts, CFG.nTrajPts);
            }

            updateOBB(nPoses);
        }
    }

    template <batchRobotConfig CFG>
    void streamCurveRobot<CFG>::updateAS(const CUdeviceptr poses) {
        updateAS(poses, CFG.BATCHSIZE);
    }

    template <batchRobotConfig CFG>
    void streamCurveRobot<CFG>::updateAS(const CUdeviceptr poses, const size_t nTraj) {
        // Update batchsize first
        using Base = streamGASRobot<CFG>;

        Base::buildInput.curveArray.numVertices   = curveCFG.nCPtsPerTraj * nTraj;
        Base::buildInput.curveArray.numPrimitives = curveCFG.nSegsPerTraj * nTraj;

        batchFkineTraj(poses, Base::transformBuffer.d_pointer(), CFG.DOF, curveCFG.nPoPerTraj, nTraj, Base::stream);

        if constexpr (CFG.TYPE == LinkType::LINEAR_CURVE) {

            // The piece wise linear representation of the curve does not need to compute the control points
            // Hense we store the traj points in cPointsBuffer

            batchSphrCntrTraj(reinterpret_cast<float*>(Base::transformBuffer.d_pointer()),
                reinterpret_cast<float*>(Base::robotPtr->getSphereCenters()),
                reinterpret_cast<float*>(cPointsBuffer.d_pointer()), curveCFG.nPoPerTraj, nTraj,
                reinterpret_cast<int*>(Base::robotPtr->getSphereIdxMap()), curveCFG.robotTotalSphereCount, CFG.DOF,
                Base::stream);

            OPTIX_CHECK(optixAccelBuild(Base::context,
                Base::stream, // CUDA stream
                &(Base::accelOptions), &(Base::buildInput),
                1, // num build inputs
                Base::tempBuffer.d_pointer(), // temp buffer
                Base::tempBuffer.sizeInBytes, // temp buffer size
                Base::GASBuffer.d_pointer(), // output buffer
                Base::GASBuffer.sizeInBytes, // output buffer size
                &(Base::GASHandle), // AS handle
                nullptr, // emitted property list
                0 // num emitted properties
                ));
        } else {
            batchSphrCntrTraj(reinterpret_cast<float*>(Base::transformBuffer.d_pointer()),
                reinterpret_cast<float*>(Base::robotPtr->getSphereCenters()),
                reinterpret_cast<float*>(tPointsBuffer.d_pointer()), curveCFG.nPoPerTraj, nTraj,
                reinterpret_cast<int*>(Base::robotPtr->getSphereIdxMap()), curveCFG.robotTotalSphereCount, CFG.DOF,
                Base::stream);

            batchGenControlPoints(reinterpret_cast<float*>(tPointsBuffer.d_pointer()),
                reinterpret_cast<float*>(cPointsBuffer.d_pointer()), curveCFG.robotTotalSphereCount * nTraj,
                Base::stream, CFG.nCtrlPts, CFG.nTrajPts);

            OPTIX_CHECK(optixAccelBuild(Base::context,
                Base::stream, // CUDA stream
                &(Base::accelOptions), &(Base::buildInput),
                1, // num build inputs
                Base::tempBuffer.d_pointer(), // temp buffer
                Base::tempBuffer.sizeInBytes, // temp buffer size
                Base::GASBuffer.d_pointer(), // output buffer
                Base::GASBuffer.sizeInBytes, // output buffer size
                &(Base::GASHandle), // AS handle
                nullptr, // emitted property list
                0 // num emitted properties
                ));
        }
    }

    template <batchRobotConfig CFG>
    void streamCurveRobot<CFG>::updateOBB(const size_t nTraj) {
        using Base = streamGASRobot<CFG>;
        if constexpr (CFG.TYPE == LinkType::LINEAR_CURVE) {
            genCurveOBB<1>(cPointsBuffer.d_pointer(), curveCFG.indexBuffer.d_pointer(), curveCFG.curveRadiusBufferPtr,
                obbBuffer.d_pointer(), curveCFG.nSegsPerTraj * nTraj, Base::stream);
        } else if constexpr (CFG.TYPE == LinkType::QUADRATIC_CURVE) {
            genCurveOBB<2>(cPointsBuffer.d_pointer(), curveCFG.indexBuffer.d_pointer(), curveCFG.curveRadiusBufferPtr,
                obbBuffer.d_pointer(), curveCFG.nSegsPerTraj * nTraj, Base::stream);
        } else {
            // raise runtime non-implemented error
            throw std::runtime_error("Cubic curve is not implemented yet!");
        }
    }

    template <batchRobotConfig CFG>
    bool streamCurveRobot<CFG>::updateWithMask(const CUdeviceptr mask, const size_t nTraj) {

        using Base = streamGASRobot<CFG>;

        transformIsValid<uint, true>(
            mask, mask, curveCFG.nSegsPerTraj * nTraj, Base::stream); // Turn mask into 0/1 array
        CUDA_CHECK_LAST("Transform");

        exclusiveScan(
            dWhereInDst.d_pointer(), mask, Base::tempBuffer.d_pointer(), curveCFG.nSegsPerTraj * nTraj, Base::stream);
        CUDA_CHECK_LAST("Exclusive Scan");


        // compact indices
        genIndex(indexMap.d_pointer(), mask, dWhereInDst.d_pointer(), curveCFG.nCPtsPerSeg,
            curveCFG.nSegsPerTraj * nTraj, Base::stream);
        CUDA_CHECK_LAST("Compact indexMap");

        // gather control points
        compactCpyCurve<true>(cPtsCmp.d_pointer(), cPointsPtr, mask, dWhereInDst.d_pointer(), segsTemplate,
            curveCFG.nCPtsPerSeg * sizeof(float3), sizeof(float3), curveCFG.nSegsPerTraj * nTraj, Base::stream);
        CUDA_CHECK_LAST("Compact control points");


        // gather radius
        compactCpyCurve<true>(radiiCmp.d_pointer(), radiiTemplate, mask, dWhereInDst.d_pointer(), segsTemplate,
            curveCFG.nCPtsPerSeg * sizeof(float), sizeof(float), curveCFG.nSegsPerTraj * nTraj, Base::stream);
        CUDA_CHECK_LAST("Compact radii");


        // download total number of segments
        uint lastMask = 0;
        uint maskCnt  = 0;
        cudaMemcpyAsync(&lastMask, reinterpret_cast<void*>(mask + (curveCFG.nSegsPerTraj * nTraj - 1) * sizeof(uint)),
            sizeof(uint), cudaMemcpyDeviceToHost, Base::stream);
        cudaMemcpyAsync(&maskCnt,
            reinterpret_cast<void*>(dWhereInDst.d_pointer() + (curveCFG.nSegsPerTraj * nTraj - 1) * sizeof(uint)),
            sizeof(uint), cudaMemcpyDeviceToHost, Base::stream);
        cudaStreamSynchronize(Base::stream);

        maskCnt += lastMask;

        // std::cout << "Mask Count: " << maskCnt << " out of " << curveCFG.nSegs << std::endl;

        if (maskCnt) {
            // build
            Base::buildInput.curveArray.numVertices   = maskCnt * curveCFG.nCPtsPerSeg;
            Base::buildInput.curveArray.numPrimitives = maskCnt;

            OPTIX_CHECK(optixAccelBuild(Base::context,
                Base::stream, // CUDA stream
                &(Base::accelOptions), &(Base::buildInput),
                1, // num build inputs
                Base::tempBuffer.d_pointer(), // temp buffer
                Base::tempBuffer.sizeInBytes, // temp buffer size
                Base::GASBuffer.d_pointer(), // output buffer
                Base::GASBuffer.sizeInBytes, // output buffer size
                &(Base::GASHandle), // AS handle
                nullptr, // emitted property list
                0 // num emitted properties
                ));
            return true;
        } else {
            return false;
        }
    }


    template <batchRobotConfig CFG>
    void streamCurveRobot<CFG>::setTemplate(const CUdeviceptr map, const CUdeviceptr radii, const CUdeviceptr segs) {
        indexMapTemplate = map;
        radiiTemplate    = radii;
        segsTemplate     = segs;
    }

    template <batchRobotConfig CFG>
    void streamCurveRobot<CFG>::downloadOBBs(std::vector<OBB>& obbs) {
        obbBuffer.download(obbs);
    }
} // namespace RTCD

namespace RTCD { // Implementation of the batchOptixCurveRobot

    template <batchRobotConfig CFG>
    batchOptixCurveRobot<CFG>::batchOptixCurveRobot() {
        baseBatchRobot<CFG.NSTREAM, CFG.TYPE>::useOBB = CFG.useOBB;
    };

    template <batchRobotConfig CFG>
    batchOptixCurveRobot<CFG>::batchOptixCurveRobot(std::shared_ptr<robot<CFG.DOF>> robotPtr,
        std::array<cudaStream_t, CFG.NSTREAM> streams, OptixDeviceContext context)
        : baseBatchRobot<CFG.NSTREAM, CFG.TYPE>(streams, context), curveCFG(robotPtr), robotPtr(robotPtr) {

        baseBatchRobot<CFG.NSTREAM, CFG.TYPE>::useOBB = CFG.useOBB;

        // We first validate the CFG
        static_assert(CFG.TYPE == LinkType::LINEAR_CURVE || CFG.TYPE == LinkType::CUBIC_CURVE
                          || CFG.TYPE == LinkType::QUADRATIC_CURVE,
            "The curve type is not supported!");

        static_assert(CFG.TYPE == LinkType::CUBIC_CURVE || CFG.TYPE == LinkType::QUADRATIC_CURVE
                          || CFG.TYPE == LinkType::LINEAR_CURVE && (CFG.nCtrlPts > 0 || CFG.nTrajPts > 0),
            "Specify the number of control points and trajectory points for the cubic/quadratic curve!");

        static_assert(CFG.nCtrlPts < CFG.nTrajPts || CFG.TYPE == LinkType::LINEAR_CURVE,
            "The number of control points should be less than the number of trajectory points!");

        static_assert(CFG.TYPE == LinkType::LINEAR_CURVE || CFG.nCtrlPts * CFG.nTrajPts <= 512,
            "The product of control points and trajectory points should be less than 512 for Quad & Cubic Spline!");

        // We then load the weight & spheres
        loadCurveWeight();
        if constexpr (CFG.TYPE == LinkType::LINEAR_CURVE || CFG.TYPE == LinkType::CUBIC_CURVE
                      || CFG.TYPE == LinkType::QUADRATIC_CURVE) {
            robotPtr->uploadSphereArrays();
        }

#if defined(_DEBUG) || defined(DEBUG)
        std::cout << "There are "
                  << std::count_if(curveCFG.curveSegmentIdxToPoseIdx.begin(), curveCFG.curveSegmentIdxToPoseIdx.end(),
                         [](int i) { return i == 0; })
                  << " for poso 0 and "
                  << std::count_if(curveCFG.curveSegmentIdxToPoseIdx.begin(), curveCFG.curveSegmentIdxToPoseIdx.end(),
                         [](int i) { return i == 1; })
                  << " for poso 1" << std::endl;
#endif

        baseBatchRobot<CFG.NSTREAM, CFG.TYPE>::mapIndex.alloc_and_upload(curveCFG.curveSegmentIdxToPoseIdx);

        // Initiate streamRobot
        for (size_t i = 0; i < CFG.NSTREAM; ++i) {
            robots[i] = std::make_unique<streamCurveRobot<CFG>>(robotPtr, streams[i], context, curveCFG);
            if constexpr (CFG.useOBB) {
                robots[i]->setTemplate(baseBatchRobot<CFG.NSTREAM, CFG.TYPE>::mapIndex.d_pointer(),
                    curveCFG.curveRadiusBuffer.d_pointer(), curveCFG.indexBuffer.d_pointer());
            }
        }
    };

    template <batchRobotConfig CFG>
    void batchOptixCurveRobot<CFG>::loadCurveWeight() {
        std::string dir = CONCAT_PATHS(PROJECT_BASE_DIR, "/RTCD/data/weights");
        std::string endPointTypeName;
        if constexpr (CFG.endPointType == curveEndPointType::Normal) {
            endPointTypeName = "normal";
        } else if constexpr (CFG.endPointType == curveEndPointType::Phantom) {
            endPointTypeName = "phantom";
        } else if constexpr (CFG.endPointType == curveEndPointType::Repeated) {
            endPointTypeName = "repeated";
        } else {
            endPointTypeName = "normal";
        }

        if constexpr (CFG.TYPE == LinkType::CUBIC_CURVE) {
            std::string weightName = dir + "/cubic/" + endPointTypeName + "/" + std::to_string(CFG.nCtrlPts) + "_"
                                   + std::to_string(CFG.nTrajPts) + ".txt";
            loadWeight<CFG>(weightName);
        } else if constexpr (CFG.TYPE == LinkType::QUADRATIC_CURVE) {
            std::string weightName = dir + "/quad/" + endPointTypeName + "/" + std::to_string(CFG.nCtrlPts) + "_"
                                   + std::to_string(CFG.nTrajPts) + ".txt";
            loadWeight<CFG>(weightName);
        } else if constexpr (CFG.TYPE == LinkType::LINEAR_CURVE) {
            // Do Nothing because piecewise linear curve does not need weight
        }
    };

    // Helper function of loadCurveWeight
    // load the weight from the file based on the curve config.
    template <batchRobotConfig CFG>
    void loadWeight(std::string fileName) {
        const std::filesystem::path p(fileName);
        if (!std::filesystem::exists(p)) {
            std::cout << "Trajectory file " << std::filesystem::absolute(p) << " does not exist!" << std::endl;
            exit(1);
        }
        std::vector<float> weight;
        std::ifstream file(fileName);
        // print the absolute path of the file
        float w;
        while (file >> w) {
            weight.push_back(w);
        }
        file.close();
        CUDA_CHECK(fillWeight(weight.data(), CFG.nTrajPts * CFG.nCtrlPts));
    };


    template <batchRobotConfig CFG>
    void batchOptixCurveRobot<CFG>::fkine(const CUdeviceptr poses, const size_t idx) {
        robots[idx]->fkine(poses);
    };

    template <batchRobotConfig CFG>
    void batchOptixCurveRobot<CFG>::fkine(const CUdeviceptr poses, const size_t idx, const size_t nPoses) {
        robots[idx]->fkine(poses, nPoses);
    };

    template <batchRobotConfig CFG>
    void batchOptixCurveRobot<CFG>::update(const CUdeviceptr poses, const size_t idx) {
        robots[idx]->updateAS(poses);
    };

    template <batchRobotConfig CFG>
    void batchOptixCurveRobot<CFG>::update(const CUdeviceptr poses, const size_t idx, const size_t nTraj) {
        robots[idx]->updateAS(poses, nTraj);
    };

    template <batchRobotConfig CFG>
    bool batchOptixCurveRobot<CFG>::updateWithMask(const CUdeviceptr mask, const size_t idx) {
        return robots[idx]->updateWithMask(mask, CFG.BATCHSIZE);
    };

    template <batchRobotConfig CFG>
    bool batchOptixCurveRobot<CFG>::updateWithMask(const CUdeviceptr mask, const size_t idx, const size_t nPoses) {
        return robots[idx]->updateWithMask(mask, nPoses);
    };

    template <batchRobotConfig CFG>
    void batchOptixCurveRobot<CFG>::buildTraversables() {};

    template <batchRobotConfig CFG>
    constexpr unsigned int batchOptixCurveRobot<CFG>::getBuildFlags() const {
        if constexpr (CFG.BUILD == BuildType::COMPACT) {
            return OPTIX_BUILD_FLAG_ALLOW_COMPACTION | OPTIX_BUILD_FLAG_PREFER_FAST_TRACE;
        }
        if constexpr (CFG.BUILD == BuildType::FAST_BUILD) {
            return OPTIX_BUILD_FLAG_PREFER_FAST_BUILD;
        }
        if constexpr (CFG.BUILD == BuildType::FAST_TRACE) {
            return OPTIX_BUILD_FLAG_PREFER_FAST_TRACE;
        }
    }

    template <batchRobotConfig CFG>
    constexpr size_t batchOptixCurveRobot<CFG>::getSBTSize() const {
        // return CFG.BATCHSIZE * robotPtr->getRobotTotalSphereCount();
        return 1;
    }

    template <batchRobotConfig CFG>
    constexpr size_t batchOptixCurveRobot<CFG>::getBatchSize() const {
        return CFG.BATCHSIZE;
    }

    template <batchRobotConfig CFG>
    CUdeviceptr batchOptixCurveRobot<CFG>::getOBBs(const size_t idx) const {
        return robots[idx]->obbBuffer.d_pointer();
    }

    template <batchRobotConfig CFG>
    size_t batchOptixCurveRobot<CFG>::getNOBBs() const {
        return curveCFG.nSegsPerTraj * CFG.BATCHSIZE;
    }

    template <batchRobotConfig CFG>
    size_t batchOptixCurveRobot<CFG>::getNOBBs(size_t nPoses) const {
        return curveCFG.nSegsPerTraj * nPoses;
    }

    template <batchRobotConfig CFG>
    void batchOptixCurveRobot<CFG>::updateOBBs(const size_t idx) {
        robots[idx]->updateOBB(CFG.BATCHSIZE);
    }

    template <batchRobotConfig CFG>
    void batchOptixCurveRobot<CFG>::updateOBBs(const size_t idx, const size_t nPoses) {
        robots[idx]->updateOBB(nPoses);
    }

    template <batchRobotConfig CFG>
    CUdeviceptr batchOptixCurveRobot<CFG>::getMapIndex(const size_t idx) const {
        return baseBatchRobot<CFG.NSTREAM, CFG.TYPE>::mapIndex.d_pointer();
    }

    template <batchRobotConfig CFG>
    void batchOptixCurveRobot<CFG>::resetGraph() {
        // No graph for curved robot
    }

    template <batchRobotConfig CFG>
    void batchOptixCurveRobot<CFG>::downloadOBBs(const size_t idx, std::vector<OBB>& obbs) {
        robots[idx]->downloadOBBs(obbs);
    }

} // namespace RTCD
